module Type
  use Ref
  use mach.int.Int
  use mach.int.Int32
  use mach.int.Int64
  use mach.int.UInt32
  use mach.int.UInt64
  use string.Char
  use floating_point.Single
  use floating_point.Double
  use prelude.Prelude
  type listindexmut_option 't = 
    | ListIndexMut_Option_None
    | ListIndexMut_Option_Some('t)
    
  predicate drop_listindexmut_option (drop_t : 't -> bool) (self : listindexmut_option 't) = 
    match (self) with
      | ListIndexMut_Option_None -> true
      | ListIndexMut_Option_Some(a) -> drop_t a
      end
  type listindexmut_list  = 
    | ListIndexMut_List(uint32, listindexmut_option (listindexmut_list))
    
  predicate drop_listindexmut_list (self : listindexmut_list) = 
    let ListIndexMut_List(a, b) = self in drop_uint a && drop_listindexmut_option drop_fix b
end
module ListIndexMut_Impl0_Resolve
  use Ref
  use mach.int.Int
  use mach.int.Int32
  use mach.int.Int64
  use mach.int.UInt32
  use mach.int.UInt64
  use string.Char
  use floating_point.Single
  use floating_point.Double
  use prelude.Prelude
  use Type
  predicate impl (self : Type.listindexmut_list) = 
    true
end
module ListIndexMut_Len
  use Ref
  use mach.int.Int
  use mach.int.Int32
  use mach.int.Int64
  use mach.int.UInt32
  use mach.int.UInt64
  use string.Char
  use floating_point.Single
  use floating_point.Double
  use prelude.Prelude
  use Type
  let rec function impl (l : Type.listindexmut_list) : int
    ensures { result >= Int32.to_int (0 : int32) }
    
   = 
    let Type.ListIndexMut_List(_, ls) = l in Int32.to_int (1 : int32) + match (ls) with
      | Type.ListIndexMut_Option_Some(ls) -> impl ls
      | Type.ListIndexMut_Option_None -> Int32.to_int (0 : int32)
      end
end
module ListIndexMut_Get
  use Ref
  use mach.int.Int
  use mach.int.Int32
  use mach.int.Int64
  use mach.int.UInt32
  use mach.int.UInt64
  use string.Char
  use floating_point.Single
  use floating_point.Double
  use prelude.Prelude
  use Type
  clone ListIndexMut_Len as Len0
  let rec function impl (l : Type.listindexmut_list) (ix : int) : Type.listindexmut_option uint32
    variant {Len0.impl l}
    
   = 
    let Type.ListIndexMut_List(i, ls) = l in match (ix > Int32.to_int (0 : int32)) with
      | False -> Type.ListIndexMut_Option_Some(i)
      | True -> match (ls) with
        | Type.ListIndexMut_Option_Some(ls) -> impl ls (ix - Int32.to_int (1 : int32))
        | Type.ListIndexMut_Option_None -> Type.ListIndexMut_Option_None
        end
      end
end
module CreusotContracts_Builtins_Resolve
  use Ref
  use mach.int.Int
  use mach.int.Int32
  use mach.int.Int64
  use mach.int.UInt32
  use mach.int.UInt64
  use string.Char
  use floating_point.Single
  use floating_point.Double
  use prelude.Prelude
  use Type
  type self   
  predicate resolve (self : self)
end
module CreusotContracts_Builtins_Impl8_Resolve
  use Ref
  use mach.int.Int
  use mach.int.Int32
  use mach.int.Int64
  use mach.int.UInt32
  use mach.int.UInt64
  use string.Char
  use floating_point.Single
  use floating_point.Double
  use prelude.Prelude
  use Type
  predicate impl (self : usize) = 
    true
end
module CreusotContracts_Builtins_Impl8
  use Ref
  use mach.int.Int
  use mach.int.Int32
  use mach.int.Int64
  use mach.int.UInt32
  use mach.int.UInt64
  use string.Char
  use floating_point.Single
  use floating_point.Double
  use prelude.Prelude
  use Type
  clone CreusotContracts_Builtins_Impl8_Resolve as Resolve0
  clone CreusotContracts_Builtins_Resolve with type self = usize, predicate resolve = Resolve0.impl
end
module CreusotContracts_Builtins_Impl12_Resolve
  use Ref
  use mach.int.Int
  use mach.int.Int32
  use mach.int.Int64
  use mach.int.UInt32
  use mach.int.UInt64
  use string.Char
  use floating_point.Single
  use floating_point.Double
  use prelude.Prelude
  use Type
  predicate impl (self : bool) = 
    true
end
module CreusotContracts_Builtins_Impl12
  use Ref
  use mach.int.Int
  use mach.int.Int32
  use mach.int.Int64
  use mach.int.UInt32
  use mach.int.UInt64
  use string.Char
  use floating_point.Single
  use floating_point.Double
  use prelude.Prelude
  use Type
  clone CreusotContracts_Builtins_Impl12_Resolve as Resolve0
  clone CreusotContracts_Builtins_Resolve with type self = bool, predicate resolve = Resolve0.impl
end
module CreusotContracts_Builtins_Impl15_Resolve
  use Ref
  use mach.int.Int
  use mach.int.Int32
  use mach.int.Int64
  use mach.int.UInt32
  use mach.int.UInt64
  use string.Char
  use floating_point.Single
  use floating_point.Double
  use prelude.Prelude
  use Type
  type t   
  predicate impl (self : borrowed t) = 
     ^ self =  * self
end
module CreusotContracts_Builtins_Impl15
  use Ref
  use mach.int.Int
  use mach.int.Int32
  use mach.int.Int64
  use mach.int.UInt32
  use mach.int.UInt64
  use string.Char
  use floating_point.Single
  use floating_point.Double
  use prelude.Prelude
  use Type
  type t   
  clone CreusotContracts_Builtins_Impl15_Resolve as Resolve0 with type t = t
  clone CreusotContracts_Builtins_Resolve with type self = borrowed t, predicate resolve = Resolve0.impl
end
module CreusotContracts_Builtins_Impl10_Resolve
  use Ref
  use mach.int.Int
  use mach.int.Int32
  use mach.int.Int64
  use mach.int.UInt32
  use mach.int.UInt64
  use string.Char
  use floating_point.Single
  use floating_point.Double
  use prelude.Prelude
  use Type
  predicate impl (self : isize) = 
    true
end
module CreusotContracts_Builtins_Impl10
  use Ref
  use mach.int.Int
  use mach.int.Int32
  use mach.int.Int64
  use mach.int.UInt32
  use mach.int.UInt64
  use string.Char
  use floating_point.Single
  use floating_point.Double
  use prelude.Prelude
  use Type
  clone CreusotContracts_Builtins_Impl10_Resolve as Resolve0
  clone CreusotContracts_Builtins_Resolve with type self = isize, predicate resolve = Resolve0.impl
end
module CreusotContracts_Builtins_Impl11_Resolve
  use Ref
  use mach.int.Int
  use mach.int.Int32
  use mach.int.Int64
  use mach.int.UInt32
  use mach.int.UInt64
  use string.Char
  use floating_point.Single
  use floating_point.Double
  use prelude.Prelude
  use Type
  predicate impl (self : ()) = 
    true
end
module CreusotContracts_Builtins_Impl11
  use Ref
  use mach.int.Int
  use mach.int.Int32
  use mach.int.Int64
  use mach.int.UInt32
  use mach.int.UInt64
  use string.Char
  use floating_point.Single
  use floating_point.Double
  use prelude.Prelude
  use Type
  clone CreusotContracts_Builtins_Impl11_Resolve as Resolve0
  clone CreusotContracts_Builtins_Resolve with type self = (), predicate resolve = Resolve0.impl
end
module Std_Process_Abort
  use Ref
  use mach.int.Int
  use mach.int.Int32
  use mach.int.Int64
  use mach.int.UInt32
  use mach.int.UInt64
  use string.Char
  use floating_point.Single
  use floating_point.Double
  use prelude.Prelude
  use Type
  val impl () : ()
    ensures { false }
    
end
module ListIndexMut_IndexMut
  use Ref
  use mach.int.Int
  use mach.int.Int32
  use mach.int.Int64
  use mach.int.UInt32
  use mach.int.UInt64
  use string.Char
  use floating_point.Single
  use floating_point.Double
  use prelude.Prelude
  use Type
  clone ListIndexMut_Len as Len0
  clone ListIndexMut_Get as Get1
  clone Std_Process_Abort as Abort8
  clone CreusotContracts_Builtins_Impl8_Resolve as Resolve2
  clone CreusotContracts_Builtins_Impl10_Resolve as Resolve5
  clone CreusotContracts_Builtins_Impl11_Resolve as Resolve7
  clone CreusotContracts_Builtins_Impl12_Resolve as Resolve3
  clone CreusotContracts_Builtins_Impl15_Resolve as Resolve9 with type t = uint32
  clone CreusotContracts_Builtins_Impl15_Resolve as Resolve4 with type t = Type.listindexmut_list
  clone CreusotContracts_Builtins_Impl15_Resolve as Resolve6 with type t = Type.listindexmut_list
  let rec cfg impl (o_param_l_1 : borrowed (Type.listindexmut_list)) (o_param_ix_2 : usize) : borrowed uint32
    requires {UInt64.to_int o_param_ix_2 < Len0.impl ( * o_param_l_1)}
    ensures { forall i : (int) . Int32.to_int (0 : int32) <= i && i < Len0.impl ( * o_param_l_1) && i <> UInt64.to_int o_param_ix_2 -> Get1.impl ( * o_param_l_1) i = Get1.impl ( ^ o_param_l_1) i }
    ensures { Len0.impl ( ^ o_param_l_1) = Len0.impl ( * o_param_l_1) }
    ensures { Type.ListIndexMut_Option_Some( ^ result) = Get1.impl ( ^ o_param_l_1) (UInt64.to_int o_param_ix_2) }
    ensures { Type.ListIndexMut_Option_Some( * result) = Get1.impl ( * o_param_l_1) (UInt64.to_int o_param_ix_2) }
    
   = 
  var _0 : borrowed uint32;
  var param_l_1 : borrowed (Type.listindexmut_list);
  var param_ix_2 : usize;
  var _3 : borrowed uint32;
  var l_4 : borrowed (Type.listindexmut_list);
  var ix_5 : usize;
  var _6 : ();
  var _12 : ();
  var _13 : bool;
  var _14 : usize;
  var _15 : ();
  var _16 : isize;
  var n_17 : borrowed (Type.listindexmut_list);
  var _18 : borrowed (Type.listindexmut_list);
  var _19 : ();
  var _20 : ();
  var _21 : borrowed uint32;
  {
    param_l_1 <- o_param_l_1;
    param_ix_2 <- o_param_ix_2;
    goto BB0
  }
  BB0 {
    assume { drop_mut_ref l_4 };
    l_4 <- param_l_1;
    assume { drop_uint ix_5 };
    ix_5 <- param_ix_2;
    assume { Resolve2.impl param_ix_2 };
    goto BB1
  }
  BB1 {
    invariant valid_ix { (0 : usize) <= ix_5 && UInt64.to_int ix_5 < Len0.impl ( * l_4) };
    invariant get_target_now { Get1.impl ( * l_4) (UInt64.to_int ix_5) = Get1.impl ( * param_l_1) (UInt64.to_int param_ix_2) };
    invariant get_target_fin { Get1.impl ( ^ l_4) (UInt64.to_int ix_5) = Get1.impl ( ^ param_l_1) (UInt64.to_int param_ix_2) };
    invariant len { Len0.impl ( ^ l_4) = Len0.impl ( * l_4) -> Len0.impl ( ^ param_l_1) = Len0.impl ( * param_l_1) };
    invariant untouched { (forall i : (int) . Int32.to_int (0 : int32) <= i && i < Len0.impl ( * l_4) && i <> UInt64.to_int ix_5 -> Get1.impl ( ^ l_4) i = Get1.impl ( * l_4) i) -> (forall i : (int) . Int32.to_int (0 : int32) <= i && i < Len0.impl ( * param_l_1) && i <> UInt64.to_int param_ix_2 -> Get1.impl ( ^ param_l_1) i = Get1.impl ( * param_l_1) i) };
    goto BB2
  }
  BB2 {
    assume { drop_uint _14 };
    _14 <- ix_5;
    _13 <- _14 > (0 : usize);
    switch (_13)
      | False -> goto BB4
      | True -> goto BB3
      | _ -> goto BB3
      end
  }
  BB3 {
    assume { Resolve3.impl _13 };
    goto BB5
  }
  BB4 {
    assume { Resolve2.impl ix_5 };
    assume { Resolve3.impl _13 };
    _6 <- ();
    assume { Resolve7.impl _6 };
    _21 <- borrow_mut (let Type.ListIndexMut_List(a, _) =  * l_4 in a);
    l_4 <- { l_4 with current = (let Type.ListIndexMut_List(a, b) =  * l_4 in Type.ListIndexMut_List( ^ _21, b)) };
    assume { Resolve4.impl l_4 };
    _3 <- borrow_mut ( * _21);
    _21 <- { _21 with current = ( ^ _3) };
    assume { Resolve9.impl _21 };
    _0 <- borrow_mut ( * _3);
    _3 <- { _3 with current = ( ^ _0) };
    assume { Resolve9.impl _3 };
    return _0
  }
  BB5 {
    switch (let Type.ListIndexMut_List(_, a) =  * l_4 in a)
      | Type.ListIndexMut_Option_None -> goto BB6
      | Type.ListIndexMut_Option_Some(_) -> goto BB7
      | _ -> goto BB8
      end
  }
  BB6 {
    assume { Resolve4.impl l_4 };
    assume { Resolve2.impl ix_5 };
    assume { Resolve5.impl _16 };
    absurd
  }
  BB7 {
    assume { Resolve5.impl _16 };
    goto BB9
  }
  BB8 {
    assume { Resolve4.impl l_4 };
    assume { Resolve2.impl ix_5 };
    assume { Resolve5.impl _16 };
    absurd
  }
  BB9 {
    n_17 <- borrow_mut (let Type.ListIndexMut_Option_Some(a) = let Type.ListIndexMut_List(_, a) =  * l_4 in a in a);
    l_4 <- { l_4 with current = (let Type.ListIndexMut_List(a, b) =  * l_4 in Type.ListIndexMut_List(a, let Type.ListIndexMut_Option_Some(a) = let Type.ListIndexMut_List(_, a) =  * l_4 in a in Type.ListIndexMut_Option_Some( ^ n_17))) };
    assume { Resolve4.impl l_4 };
    _18 <- borrow_mut ( * n_17);
    n_17 <- { n_17 with current = ( ^ _18) };
    assume { Resolve6.impl n_17 };
    assume { drop_mut_ref l_4 };
    l_4 <- _18;
    _15 <- ();
    assume { Resolve7.impl _15 };
    ix_5 <- ix_5 - (1 : usize);
    _12 <- ();
    assume { Resolve7.impl _12 };
    goto BB1
  }
  
end
module CreusotContracts_Builtins_Impl7_Resolve
  use Ref
  use mach.int.Int
  use mach.int.Int32
  use mach.int.Int64
  use mach.int.UInt32
  use mach.int.UInt64
  use string.Char
  use floating_point.Single
  use floating_point.Double
  use prelude.Prelude
  use Type
  predicate impl (self : uint32) = 
    true
end
module CreusotContracts_Builtins_Impl7
  use Ref
  use mach.int.Int
  use mach.int.Int32
  use mach.int.Int64
  use mach.int.UInt32
  use mach.int.UInt64
  use string.Char
  use floating_point.Single
  use floating_point.Double
  use prelude.Prelude
  use Type
  clone CreusotContracts_Builtins_Impl7_Resolve as Resolve0
  clone CreusotContracts_Builtins_Resolve with type self = uint32, predicate resolve = Resolve0.impl
end
module ListIndexMut_Write
  use Ref
  use mach.int.Int
  use mach.int.Int32
  use mach.int.Int64
  use mach.int.UInt32
  use mach.int.UInt64
  use string.Char
  use floating_point.Single
  use floating_point.Double
  use prelude.Prelude
  use Type
  clone ListIndexMut_Len as Len5
  clone ListIndexMut_Get as Get6
  clone ListIndexMut_IndexMut as IndexMut3
  clone CreusotContracts_Builtins_Impl7_Resolve as Resolve0
  clone CreusotContracts_Builtins_Impl8_Resolve as Resolve2
  clone CreusotContracts_Builtins_Impl15_Resolve as Resolve4 with type t = uint32
  clone CreusotContracts_Builtins_Impl15_Resolve as Resolve1 with type t = Type.listindexmut_list
  let rec cfg impl (o_l_1 : borrowed (Type.listindexmut_list)) (o_ix_2 : usize) (o_val_3 : uint32) : ()
    requires {UInt64.to_int o_ix_2 < Len5.impl ( * o_l_1)}
    ensures { forall i : (int) . Int32.to_int (0 : int32) <= i && i < Len5.impl ( * o_l_1) && i <> UInt64.to_int o_ix_2 -> Get6.impl ( * o_l_1) i = Get6.impl ( ^ o_l_1) i }
    ensures { Len5.impl ( ^ o_l_1) = Len5.impl ( * o_l_1) }
    ensures { Type.ListIndexMut_Option_Some(o_val_3) = Get6.impl ( ^ o_l_1) (UInt64.to_int o_ix_2) }
    
   = 
  var _0 : ();
  var l_1 : borrowed (Type.listindexmut_list);
  var ix_2 : usize;
  var val_3 : uint32;
  var _4 : uint32;
  var _5 : borrowed uint32;
  var _6 : borrowed (Type.listindexmut_list);
  var _7 : usize;
  {
    l_1 <- o_l_1;
    ix_2 <- o_ix_2;
    val_3 <- o_val_3;
    goto BB0
  }
  BB0 {
    assume { drop_uint _4 };
    _4 <- val_3;
    assume { Resolve0.impl val_3 };
    _6 <- borrow_mut ( * l_1);
    l_1 <- { l_1 with current = ( ^ _6) };
    assume { Resolve1.impl l_1 };
    assume { drop_uint _7 };
    _7 <- ix_2;
    assume { Resolve2.impl ix_2 };
    _5 <- IndexMut3.impl _6 _7;
    goto BB1
  }
  BB1 {
    assume { drop_uint ( * _5) };
    _5 <- { _5 with current = _4 };
    assume { Resolve0.impl _4 };
    assume { Resolve4.impl _5 };
    _0 <- ();
    return _0
  }
  
end
module ListIndexMut_Impl0
  use Ref
  use mach.int.Int
  use mach.int.Int32
  use mach.int.Int64
  use mach.int.UInt32
  use mach.int.UInt64
  use string.Char
  use floating_point.Single
  use floating_point.Double
  use prelude.Prelude
  use Type
  clone ListIndexMut_Impl0_Resolve as Resolve0
  clone CreusotContracts_Builtins_Resolve with type self = Type.listindexmut_list, predicate resolve = Resolve0.impl
end
module ListIndexMut_Main
  use Ref
  use mach.int.Int
  use mach.int.Int32
  use mach.int.Int64
  use mach.int.UInt32
  use mach.int.UInt64
  use string.Char
  use floating_point.Single
  use floating_point.Double
  use prelude.Prelude
  use Type
  clone ListIndexMut_Impl0_Resolve as Resolve2
  clone ListIndexMut_Write as Write1
  clone CreusotContracts_Builtins_Impl15_Resolve as Resolve0 with type t = Type.listindexmut_list
  let rec cfg impl () : () = 
  var _0 : ();
  var l_1 : Type.listindexmut_list;
  var _2 : Type.listindexmut_option (Type.listindexmut_list);
  var _3 : Type.listindexmut_list;
  var _4 : Type.listindexmut_list;
  var _5 : Type.listindexmut_option (Type.listindexmut_list);
  var _6 : ();
  var _7 : borrowed (Type.listindexmut_list);
  var _8 : borrowed (Type.listindexmut_list);
  {
    goto BB0
  }
  BB0 {
    _5 <- Type.ListIndexMut_Option_None;
    _4 <- Type.ListIndexMut_List((10 : uint32), _5);
    goto BB1
  }
  BB1 {
    _3 <- _4;
    goto BB2
  }
  BB2 {
    _2 <- Type.ListIndexMut_Option_Some(_3);
    goto BB3
  }
  BB3 {
    l_1 <- Type.ListIndexMut_List((1 : uint32), _2);
    goto BB4
  }
  BB4 {
    _8 <- borrow_mut l_1;
    l_1 <-  ^ _8;
    _7 <- borrow_mut ( * _8);
    _8 <- { _8 with current = ( ^ _7) };
    assume { Resolve0.impl _8 };
    _6 <- Write1.impl _7 (0 : usize) (2 : uint32);
    goto BB5
  }
  BB5 {
    assume { Resolve0.impl _7 };
    _0 <- ();
    goto BB6
  }
  BB6 {
    assume { Resolve2.impl l_1 };
    return _0
  }
  
end
