
module C10Tyinv_Zero_Type
  use prelude.prelude.UInt32
  
  use prelude.prelude.Int
  
  type t_zero 't =
    | C_Zero uint32 't
  
  function any_l (_ : 'b) : 'a
  
  let rec t_zero < 't > (input:t_zero 't) (ret  (field_0:uint32) (field_1:'t))= any
    [ good (field_0:uint32) (field_1:'t)-> {C_Zero field_0 field_1 = input} (! ret {field_0} {field_1})
    | bad (field_0:uint32) (field_1:'t)-> {C_Zero field_0 field_1 <> input} {false} any ]
    
  
  function zero_0 (self : t_zero 't) : uint32 =
    match self with
      | C_Zero a _ -> a
      end
end
module C10Tyinv_F_Closure0_Closure1_Type
  use prelude.prelude.UInt32
  
  use prelude.prelude.Int8
  
  use C10Tyinv_Zero_Type as Zero'0
  
  use prelude.prelude.Borrow
  
  type c10tyinv_f_closure0_closure1 't =
    | C10tyinv_f_closure0_closure1 (Zero'0.t_zero 't)
  
  let rec c10tyinv_f_closure0_closure1 < 't > (input:c10tyinv_f_closure0_closure1 't) (ret  (y:Zero'0.t_zero 't))= any
    [ good (y:Zero'0.t_zero 't)-> {C10tyinv_f_closure0_closure1 y = input} (! ret {y})
    | bad (y:Zero'0.t_zero 't)-> {C10tyinv_f_closure0_closure1 y <> input} {false} any ]
    
end
module C10Tyinv_F_Closure0_Closure1
  type t
  
  let%span s10_tyinv0 = "../10_tyinv.rs" 20 26 20 35
  
  let%span s10_tyinv1 = "../10_tyinv.rs" 18 30 18 42
  
  let%span span2 = "../10_tyinv.rs" 10 20 10 32
  
  let%span span3 = "../../../../../creusot-contracts/src/invariant.rs" 26 8 26 18
  
  predicate invariant'3 (self : t)
  
  predicate inv'4 (_1 : t)
  
  axiom inv'4 [@rewrite] : forall x : t . inv'4 x = true
  
  use prelude.prelude.UInt32
  
  use C10Tyinv_Zero_Type as C10Tyinv_Zero_Type
  
  use C10Tyinv_Zero_Type as Zero'0
  
  predicate invariant'2 [#"../10_tyinv.rs" 9 4 9 30] (self : Zero'0.t_zero t) =
    [%#span2] UInt32.to_int (C10Tyinv_Zero_Type.zero_0 self) = 0
  
  predicate inv'3 (_1 : Zero'0.t_zero t)
  
  axiom inv'3 [@rewrite] : forall x : Zero'0.t_zero t . inv'3 x
  = (invariant'2 x
  /\ match x with
    | Zero'0.C_Zero a_0 a_1 -> true
    end)
  
  use prelude.prelude.Borrow
  
  predicate invariant'1 (self : Zero'0.t_zero t) =
    [%#span3] inv'3 self
  
  predicate inv'2 (_1 : Zero'0.t_zero t)
  
  axiom inv'2 [@rewrite] : forall x : Zero'0.t_zero t . inv'2 x = invariant'1 x
  
  use prelude.prelude.UInt32
  
  use prelude.prelude.Int8
  
  use C10Tyinv_F_Closure0_Closure1_Type as Closure'0
  
  predicate inv'1 (_1 : Closure'0.c10tyinv_f_closure0_closure1 t)
  
  axiom inv'1 [@rewrite] : forall x : Closure'0.c10tyinv_f_closure0_closure1 t . inv'1 x
  = (let Closure'0.C10tyinv_f_closure0_closure1 a = x in inv'2 a)
  
  predicate invariant'0 (self : Closure'0.c10tyinv_f_closure0_closure1 t) =
    [%#span3] inv'1 self
  
  predicate inv'0 (_1 : Closure'0.c10tyinv_f_closure0_closure1 t)
  
  axiom inv'0 [@rewrite] : forall x : Closure'0.c10tyinv_f_closure0_closure1 t . inv'0 x = invariant'0 x
  
  use prelude.prelude.Intrinsic
  
  use prelude.prelude.Int
  
  function field_0'0 [#"../10_tyinv.rs" 18 20 18 44] (self : Closure'0.c10tyinv_f_closure0_closure1 t) : Zero'0.t_zero t
   =
    let Closure'0.C10tyinv_f_closure0_closure1 a = self in a
  
  let rec c10tyinv_f_closure0_closure1 (_1:Closure'0.c10tyinv_f_closure0_closure1 t) (return'  (ret:uint32))= {inv'0 _1}
    (! bb0
    [ bb0 = s0
      [ s0 = {[@expl:assertion] [%#s10_tyinv0] UInt32.to_int (C10Tyinv_Zero_Type.zero_0 (field_0'0 _1)) = 0} s1
      | s1 = Closure'0.c10tyinv_f_closure0_closure1 <t> {_1}
          (fun (r'0:Zero'0.t_zero t) -> Zero'0.t_zero <t> {r'0} (fun (r0'0:uint32) (r1'0:t) ->  [ &res <- r0'0 ] s2))
      | s2 =  [ &_0 <- res ] s3
      | s3 = return' {_0} ]
       ]
    ) [ & _0 : uint32 = any_l () | & _1 : Closure'0.c10tyinv_f_closure0_closure1 t = _1 | & res : uint32 = any_l () ] 
    [ return' (result:uint32)-> {[@expl:postcondition] [%#s10_tyinv1] UInt32.to_int result = 0} (! return' {result}) ]
    
end
module C10Tyinv_F_Closure0_Type
  use prelude.prelude.UInt32
  
  use prelude.prelude.Int8
  
  use C10Tyinv_Zero_Type as Zero'0
  
  use prelude.prelude.Borrow
  
  type c10tyinv_f_closure0 't =
    | C10tyinv_f_closure0 (Zero'0.t_zero 't) (Zero'0.t_zero 't)
  
  let rec c10tyinv_f_closure0 < 't > (input:c10tyinv_f_closure0 't) (ret  (x:Zero'0.t_zero 't) (y:Zero'0.t_zero 't))= any
    [ good (x:Zero'0.t_zero 't) (y:Zero'0.t_zero 't)-> {C10tyinv_f_closure0 x y = input} (! ret {x} {y})
    | bad (x:Zero'0.t_zero 't) (y:Zero'0.t_zero 't)-> {C10tyinv_f_closure0 x y <> input} {false} any ]
    
end
module C10Tyinv_F_Closure0
  type t
  
  let%span s10_tyinv0 = "../10_tyinv.rs" 17 22 17 31
  
  let%span s10_tyinv1 = "../10_tyinv.rs" 15 25 15 37
  
  let%span span2 = "../10_tyinv.rs" 10 20 10 32
  
  let%span span3 = "../../../../../creusot-contracts/src/invariant.rs" 26 8 26 18
  
  let%span span4 = "../10_tyinv.rs" 18 30 18 42
  
  predicate invariant'4 (self : t)
  
  predicate inv'6 (_1 : t)
  
  axiom inv'6 [@rewrite] : forall x : t . inv'6 x = true
  
  use prelude.prelude.UInt32
  
  use C10Tyinv_Zero_Type as C10Tyinv_Zero_Type
  
  use C10Tyinv_Zero_Type as Zero'0
  
  predicate invariant'3 [#"../10_tyinv.rs" 9 4 9 30] (self : Zero'0.t_zero t) =
    [%#span2] UInt32.to_int (C10Tyinv_Zero_Type.zero_0 self) = 0
  
  predicate inv'5 (_1 : Zero'0.t_zero t)
  
  axiom inv'5 [@rewrite] : forall x : Zero'0.t_zero t . inv'5 x
  = (invariant'3 x
  /\ match x with
    | Zero'0.C_Zero a_0 a_1 -> true
    end)
  
  use prelude.prelude.Borrow
  
  predicate invariant'2 (self : Zero'0.t_zero t) =
    [%#span3] inv'5 self
  
  predicate inv'4 (_1 : Zero'0.t_zero t)
  
  axiom inv'4 [@rewrite] : forall x : Zero'0.t_zero t . inv'4 x = invariant'2 x
  
  use prelude.prelude.UInt32
  
  use prelude.prelude.Int8
  
  use C10Tyinv_F_Closure0_Closure1_Type as Closure'1
  
  predicate inv'3 (_1 : Closure'1.c10tyinv_f_closure0_closure1 t)
  
  axiom inv'3 [@rewrite] : forall x : Closure'1.c10tyinv_f_closure0_closure1 t . inv'3 x
  = (let Closure'1.C10tyinv_f_closure0_closure1 a = x in inv'4 a)
  
  use C10Tyinv_F_Closure0_Type as Closure'0
  
  predicate inv'2 (_1 : Closure'0.c10tyinv_f_closure0 t)
  
  axiom inv'2 [@rewrite] : forall x : Closure'0.c10tyinv_f_closure0 t . inv'2 x
  = (let Closure'0.C10tyinv_f_closure0 a b = x in inv'4 a /\ inv'4 b)
  
  predicate invariant'1 (self : Closure'1.c10tyinv_f_closure0_closure1 t) =
    [%#span3] inv'3 self
  
  predicate inv'1 (_1 : Closure'1.c10tyinv_f_closure0_closure1 t)
  
  axiom inv'1 [@rewrite] : forall x : Closure'1.c10tyinv_f_closure0_closure1 t . inv'1 x = invariant'1 x
  
  predicate invariant'0 (self : Closure'0.c10tyinv_f_closure0 t) =
    [%#span3] inv'2 self
  
  predicate inv'0 (_1 : Closure'0.c10tyinv_f_closure0 t)
  
  axiom inv'0 [@rewrite] : forall x : Closure'0.c10tyinv_f_closure0 t . inv'0 x = invariant'0 x
  
  use prelude.prelude.Intrinsic
  
  use prelude.prelude.Int
  
  function field_0'1 [#"../10_tyinv.rs" 18 20 18 44] (self : Closure'1.c10tyinv_f_closure0_closure1 t) : Zero'0.t_zero t
   =
    let Closure'1.C10tyinv_f_closure0_closure1 a = self in a
  
  let rec closure1'0 (_1:Closure'1.c10tyinv_f_closure0_closure1 t) (return'  (ret:uint32))= {[@expl:precondition] inv'1 _1}
    any [ return' (result:uint32)-> {[%#span4] UInt32.to_int result = 0} (! return' {result}) ] 
  
  function field_0'0 [#"../10_tyinv.rs" 15 15 15 39] (self : Closure'0.c10tyinv_f_closure0 t) : Zero'0.t_zero t =
    let Closure'0.C10tyinv_f_closure0 a _ = self in a
  
  let rec c10tyinv_f_closure0 (_1:Closure'0.c10tyinv_f_closure0 t) (return'  (ret:uint32))= {inv'0 _1}
    (! bb0
    [ bb0 = s0
      [ s0 = {[@expl:assertion] [%#s10_tyinv0] UInt32.to_int (C10Tyinv_Zero_Type.zero_0 (field_0'0 _1)) = 0} s1
      | s1 = Closure'0.c10tyinv_f_closure0 <t> {_1}
          (fun (r'0:Zero'0.t_zero t) (r'1:Zero'0.t_zero t) ->
             [ &clos2 <- Closure'1.C10tyinv_f_closure0_closure1 r'1 ] 
            s2)
      | s2 = closure1'0 {clos2} (fun (_ret':uint32) ->  [ &_7 <- _ret' ] s3)
      | s3 = bb1 ]
      
    | bb1 = s0
      [ s0 = Closure'0.c10tyinv_f_closure0 <t> {_1}
          (fun (r'0:Zero'0.t_zero t) (r'1:Zero'0.t_zero t) ->
            Zero'0.t_zero <t> {r'0} (fun (r0'0:uint32) (r1'0:t) ->  [ &res <- r0'0 ] s1))
      | s1 =  [ &_0 <- res ] s2
      | s2 = return' {_0} ]
       ]
    )
    [ & _0 : uint32 = any_l ()
    | & _1 : Closure'0.c10tyinv_f_closure0 t = _1
    | & res : uint32 = any_l ()
    | & clos2 : Closure'1.c10tyinv_f_closure0_closure1 t = any_l ()
    | & _7 : uint32 = any_l ()
    | & _9 : () = any_l () ]
     [ return' (result:uint32)-> {[@expl:postcondition] [%#s10_tyinv1] UInt32.to_int result = 0} (! return' {result}) ] 
end
module C10Tyinv_F
  type t
  
  let%span s10_tyinv0 = "../10_tyinv.rs" 14 12 14 13
  
  let%span s10_tyinv1 = "../10_tyinv.rs" 14 24 14 25
  
  let%span span2 = "../../../../../creusot-contracts/src/invariant.rs" 26 8 26 18
  
  let%span span3 = "../10_tyinv.rs" 10 20 10 32
  
  let%span span4 = "../10_tyinv.rs" 18 30 18 42
  
  let%span span5 = "../10_tyinv.rs" 15 25 15 37
  
  use C10Tyinv_Zero_Type as Zero'0
  
  predicate inv'0 (_1 : Zero'0.t_zero t)
  
  use prelude.prelude.Borrow
  
  predicate invariant'4 (self : Zero'0.t_zero t) =
    [%#span2] inv'0 self
  
  predicate inv'6 (_1 : Zero'0.t_zero t)
  
  axiom inv'6 [@rewrite] : forall x : Zero'0.t_zero t . inv'6 x = invariant'4 x
  
  use prelude.prelude.UInt32
  
  use prelude.prelude.Int8
  
  use C10Tyinv_F_Closure0_Closure1_Type as Closure'1
  
  predicate inv'5 (_1 : Closure'1.c10tyinv_f_closure0_closure1 t)
  
  axiom inv'5 [@rewrite] : forall x : Closure'1.c10tyinv_f_closure0_closure1 t . inv'5 x
  = (let Closure'1.C10tyinv_f_closure0_closure1 a = x in inv'6 a)
  
  use C10Tyinv_F_Closure0_Type as Closure'0
  
  predicate inv'4 (_1 : Closure'0.c10tyinv_f_closure0 t)
  
  axiom inv'4 [@rewrite] : forall x : Closure'0.c10tyinv_f_closure0 t . inv'4 x
  = (let Closure'0.C10tyinv_f_closure0 a b = x in inv'6 a /\ inv'6 b)
  
  predicate invariant'3 (self : t)
  
  predicate inv'3 (_1 : t)
  
  axiom inv'3 [@rewrite] : forall x : t . inv'3 x = true
  
  predicate invariant'2 (self : Closure'1.c10tyinv_f_closure0_closure1 t) =
    [%#span2] inv'5 self
  
  predicate inv'2 (_1 : Closure'1.c10tyinv_f_closure0_closure1 t)
  
  axiom inv'2 [@rewrite] : forall x : Closure'1.c10tyinv_f_closure0_closure1 t . inv'2 x = invariant'2 x
  
  predicate invariant'1 (self : Closure'0.c10tyinv_f_closure0 t) =
    [%#span2] inv'4 self
  
  predicate inv'1 (_1 : Closure'0.c10tyinv_f_closure0 t)
  
  axiom inv'1 [@rewrite] : forall x : Closure'0.c10tyinv_f_closure0 t . inv'1 x = invariant'1 x
  
  use prelude.prelude.UInt32
  
  use C10Tyinv_Zero_Type as C10Tyinv_Zero_Type
  
  predicate invariant'0 [#"../10_tyinv.rs" 9 4 9 30] (self : Zero'0.t_zero t) =
    [%#span3] UInt32.to_int (C10Tyinv_Zero_Type.zero_0 self) = 0
  
  axiom inv'0 [@rewrite] : forall x : Zero'0.t_zero t . inv'0 x
  = (invariant'0 x
  /\ match x with
    | Zero'0.C_Zero a_0 a_1 -> true
    end)
  
  use prelude.prelude.Intrinsic
  
  use prelude.prelude.Int
  
  function field_0'1 [#"../10_tyinv.rs" 18 20 18 44] (self : Closure'1.c10tyinv_f_closure0_closure1 t) : Zero'0.t_zero t
   =
    let Closure'1.C10tyinv_f_closure0_closure1 a = self in a
  
  let rec closure1'0 (_1:Closure'1.c10tyinv_f_closure0_closure1 t) (return'  (ret:uint32))= {[@expl:precondition] inv'2 _1}
    any [ return' (result:uint32)-> {[%#span4] UInt32.to_int result = 0} (! return' {result}) ] 
  
  function field_0'0 [#"../10_tyinv.rs" 15 15 15 39] (self : Closure'0.c10tyinv_f_closure0 t) : Zero'0.t_zero t =
    let Closure'0.C10tyinv_f_closure0 a _ = self in a
  
  let rec closure0'0 (_1:Closure'0.c10tyinv_f_closure0 t) (return'  (ret:uint32))= {[@expl:precondition] inv'1 _1}
    any [ return' (result:uint32)-> {[%#span5] UInt32.to_int result = 0} (! return' {result}) ] 
  
  let rec f (x:Zero'0.t_zero t) (y:Zero'0.t_zero t) (return'  (ret:()))= {[%#s10_tyinv1] inv'0 y}
    {[%#s10_tyinv0] inv'0 x}
    (! bb0
    [ bb0 = s0
      [ s0 =  [ &clos <- Closure'0.C10tyinv_f_closure0 x y ] s1
      | s1 = closure0'0 {clos} (fun (_ret':uint32) ->  [ &_6 <- _ret' ] s2)
      | s2 = bb1 ]
      
    | bb1 = s0 [ s0 = {[@expl:type invariant] inv'0 y} s1 | s1 = {[@expl:type invariant] inv'0 x} s2 | s2 = bb2 ] 
    | bb2 = bb3
    | bb3 = return' {_0} ]
    )
    [ & _0 : () = any_l ()
    | & x : Zero'0.t_zero t = x
    | & y : Zero'0.t_zero t = y
    | & clos : Closure'0.c10tyinv_f_closure0 t = any_l ()
    | & _6 : uint32 = any_l ()
    | & _8 : () = any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module C10Tyinv_Impl0
  type t
end
