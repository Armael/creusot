
module Core_Ptr_NonNull_NonNull_Type
  use prelude.prelude.Opaque
  
  type t_nonnull 't =
    | C_NonNull opaque_ptr
  
  function any_l (_ : 'b) : 'a
  
  let rec t_nonnull < 't > (input:t_nonnull 't) (ret  (pointer:opaque_ptr))= any
    [ good (pointer:opaque_ptr)-> {C_NonNull pointer = input} (! ret {pointer})
    | bad (pointer:opaque_ptr)-> {C_NonNull pointer <> input} {false} any ]
    
end
module Core_Marker_PhantomData_Type
  type t_phantomdata 't =
    | C_PhantomData
  
  function any_l (_ : 'b) : 'a
  
  let rec t_phantomdata < 't > (input:t_phantomdata 't) (ret  )= any
    [ good -> {C_PhantomData  = input} (! ret) | bad -> {C_PhantomData  <> input} {false} any ]
    
end
module Core_Ptr_Unique_Unique_Type
  use Core_Marker_PhantomData_Type as PhantomData'0
  
  use Core_Ptr_NonNull_NonNull_Type as NonNull'0
  
  type t_unique 't =
    | C_Unique (NonNull'0.t_nonnull 't) (PhantomData'0.t_phantomdata 't)
  
  function any_l (_ : 'b) : 'a
  
  let rec t_unique < 't > (input:t_unique 't) (ret  (pointer:NonNull'0.t_nonnull 't) (_marker:PhantomData'0.t_phantomdata 't))= any
    [ good (pointer:NonNull'0.t_nonnull 't) (_marker:PhantomData'0.t_phantomdata 't)-> {C_Unique pointer _marker
      = input}
      (! ret {pointer} {_marker})
    | bad (pointer:NonNull'0.t_nonnull 't) (_marker:PhantomData'0.t_phantomdata 't)-> {C_Unique pointer _marker
      <> input}
      {false}
      any ]
    
end
module Alloc_Boxed_Box_Type
  use Core_Ptr_Unique_Unique_Type as Unique'0
  
  type t_box 't 'a =
    | C_Box (Unique'0.t_unique 't) 'a
  
  function any_l (_ : 'b) : 'a
end
module Alloc_Alloc_Global_Type
  type t_global  =
    | C_Global
  
  function any_l (_ : 'b) : 'a
  
  let rec t_global (input:t_global) (ret  )= any
    [ good -> {C_Global  = input} (! ret) | bad -> {C_Global  <> input} {false} any ]
    
end
module Trigger2_ResolveSeq_Impl
  type t
  
  let%span strigger20 = "../trigger2.rs" 6 18 6 21
  
  let%span strigger21 = "../trigger2.rs" 5 0 5 36
  
  let%span strigger22 = "../trigger2.rs" 7 4 10 5
  
  let%span span3 = "../../../../creusot-contracts/src/invariant.rs" 35 20 35 44
  
  let%span span4 = "../../../../creusot-contracts/src/std/boxed.rs" 27 8 27 18
  
  let%span span5 = "../../../../creusot-contracts/src/logic/seq.rs" 197 8 197 97
  
  let%span span6 = "../../../../creusot-contracts/src/resolve.rs" 46 8 46 12
  
  predicate invariant'3 (self : t)
  
  predicate inv'3 (_x : t)
  
  axiom inv'3 : forall x : t . inv'3 x = true
  
  use prelude.prelude.Borrow
  
  predicate invariant'2 (self : borrowed t) =
    [%#span3] inv'3 self.current /\ inv'3 self.final
  
  predicate inv'2 (_x : borrowed t)
  
  axiom inv'2 : forall x : borrowed t . inv'2 x = true
  
  use Alloc_Alloc_Global_Type as Global'0
  
  predicate invariant'1 (self : borrowed t) =
    [%#span4] inv'2 self
  
  predicate inv'1 (_x : borrowed t)
  
  axiom inv'1 : forall x : borrowed t . inv'1 x = true
  
  use seq.Seq
  
  use seq.Seq
  
  use prelude.prelude.Int
  
  use seq.Seq
  
  predicate invariant'0 (self : Seq.seq (borrowed t)) =
    [%#span5] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'1 (Seq.get self i)
  
  predicate inv'0 (_x : Seq.seq (borrowed t))
  
  axiom inv'0 : forall x : Seq.seq (borrowed t) . inv'0 x = true
  
  use seq.Seq
  
  predicate resolve'0 (self : Seq.seq (borrowed t)) =
    [%#span6] true
  
  constant seq  : Seq.seq (borrowed t)
  
  predicate resolve_seq [#"../trigger2.rs" 6 0 6 43] (seq : Seq.seq (borrowed t))
  
  goal vc_resolve_seq : ([%#strigger20] inv'0 seq)
   -> ([%#strigger21] resolve'0 seq
   -> ([%#strigger22] forall i : int [Seq.get seq i] . 0 < i /\ i <= Seq.length seq
   -> (Seq.get seq i).current = (Seq.get seq i).final))
end
module Trigger2_ResolveSeq2_Impl
  type t
  
  let%span strigger20 = "../trigger2.rs" 16 23 16 26
  
  let%span strigger21 = "../trigger2.rs" 14 0 14 36
  
  let%span strigger22 = "../trigger2.rs" 6 18 6 21
  
  let%span strigger23 = "../trigger2.rs" 5 0 5 36
  
  let%span span4 = "../../../../creusot-contracts/src/invariant.rs" 35 20 35 44
  
  let%span span5 = "../../../../creusot-contracts/src/std/boxed.rs" 27 8 27 18
  
  let%span span6 = "../../../../creusot-contracts/src/logic/seq.rs" 197 8 197 97
  
  let%span span7 = "../../../../creusot-contracts/src/resolve.rs" 46 8 46 12
  
  let%span span8 = "../trigger2.rs" 7 4 10 5
  
  predicate invariant'3 (self : t)
  
  predicate inv'3 (_x : t)
  
  axiom inv'3 : forall x : t . inv'3 x = true
  
  use prelude.prelude.Borrow
  
  predicate invariant'2 (self : borrowed t) =
    [%#span4] inv'3 self.current /\ inv'3 self.final
  
  predicate inv'2 (_x : borrowed t)
  
  axiom inv'2 : forall x : borrowed t . inv'2 x = true
  
  use Alloc_Alloc_Global_Type as Global'0
  
  predicate invariant'1 (self : borrowed t) =
    [%#span5] inv'2 self
  
  predicate inv'1 (_x : borrowed t)
  
  axiom inv'1 : forall x : borrowed t . inv'1 x = true
  
  use seq.Seq
  
  use seq.Seq
  
  use prelude.prelude.Int
  
  use seq.Seq
  
  predicate invariant'0 (self : Seq.seq (borrowed t)) =
    [%#span6] forall i : int . 0 <= i /\ i < Seq.length self  -> inv'1 (Seq.get self i)
  
  predicate inv'0 (_x : Seq.seq (borrowed t))
  
  axiom inv'0 : forall x : Seq.seq (borrowed t) . inv'0 x = true
  
  use seq.Seq
  
  predicate resolve'0 (self : Seq.seq (borrowed t)) =
    [%#span7] true
  
  predicate resolve_seq'0 [#"../trigger2.rs" 6 0 6 43] (seq : Seq.seq (borrowed t)) =
    [%#span8] forall i : int [Seq.get seq i] . 0 < i /\ i <= Seq.length seq
     -> (Seq.get seq i).current = (Seq.get seq i).final
  
  axiom resolve_seq'0_spec : forall seq : Seq.seq (borrowed t) . ([%#strigger22] inv'0 seq)
   -> ([%#strigger23] resolve'0 seq  -> resolve_seq'0 seq)
  
  constant seq  : Seq.seq (borrowed t)
  
  predicate resolve_seq2 [#"../trigger2.rs" 16 0 16 48] (seq : Seq.seq (borrowed t))
  
  goal vc_resolve_seq2 : ([%#strigger20] inv'0 seq)
   -> ([%#strigger22] inv'0 seq)
  /\ (([%#strigger23] resolve'0 seq  -> resolve_seq'0 seq)  -> ([%#strigger21] resolve'0 seq  -> resolve_seq'0 seq))
end
