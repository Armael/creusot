
module OpenInv_IsZero_Type
  use prelude.prelude.Int32
  
  use prelude.prelude.Int
  
  type t_iszero  =
    | C_IsZero int32
  
  function any_l (_ : 'b) : 'a
  
  let rec t_iszero (input:t_iszero) (ret  (field_0:int32))= any
    [ good (field_0:int32)-> {C_IsZero field_0 = input} (! ret {field_0})
    | bad (field_0:int32)-> {C_IsZero field_0 <> input} {false} any ]
    
  
  function iszero_0 (self : t_iszero) : int32 =
    match self with
      | C_IsZero a -> a
      end
end
module OpenInv_TestOpenInvParam
  use OpenInv_IsZero_Type as IsZero'0
  
  use prelude.prelude.Intrinsic
  
  let rec test_open_inv_param (_1:IsZero'0.t_iszero) (return'  (ret:()))= (! bb0 [ bb0 = return' {_0} ] )
    [ & _0 : () = any_l () ]
     [ return' (result:())-> (! return' {result}) ] 
end
module OpenInv_TestOpenInvParamCall
  let%span sopen_inv0 = "../open_inv.rs" 17 23 17 24
  
  let%span sopen_inv1 = "../open_inv.rs" 18 11 18 12
  
  use prelude.prelude.Intrinsic
  
  use OpenInv_IsZero_Type as IsZero'0
  
  let rec test_open_inv_param'0 (_1:IsZero'0.t_iszero) (return'  (ret:()))= any
    [ return' (result:())-> (! return' {result}) ]
    
  
  use prelude.prelude.Int32
  
  use prelude.prelude.Int
  
  let rec test_open_inv_param_call (_1:()) (return'  (ret:()))= (! bb0
    [ bb0 = s0
      [ s0 =  [ &a <- IsZero'0.C_IsZero ([%#sopen_inv0] (0 : int32)) ] s1
      | s1 = IsZero'0.t_iszero {a}
          (fun (r0'0:int32) ->
            Int32.sub {r0'0} {[%#sopen_inv1] (1 : int32)}
              (fun (_ret':int32) -> IsZero'0.t_iszero {a} (fun (l_0'0:int32) ->  [ &a <- IsZero'0.C_IsZero _ret' ] s2)))
      | s2 = test_open_inv_param'0 {a} (fun (_ret':()) ->  [ &_2 <- _ret' ] s3)
      | s3 = bb1 ]
      
    | bb1 = return' {_0} ]
    ) [ & _0 : () = any_l () | & a : IsZero'0.t_iszero = any_l () | & _2 : () = any_l () ] 
    [ return' (result:())-> (! return' {result}) ]
    
end
module OpenInv_TestOpenInvResult
  let%span sopen_inv0 = "../open_inv.rs" 24 23 24 24
  
  let%span sopen_inv1 = "../open_inv.rs" 25 11 25 12
  
  use prelude.prelude.Intrinsic
  
  use OpenInv_IsZero_Type as IsZero'0
  
  use prelude.prelude.Int32
  
  use prelude.prelude.Int
  
  let rec test_open_inv_result (_1:()) (return'  (ret:IsZero'0.t_iszero))= (! bb0
    [ bb0 = s0
      [ s0 =  [ &a <- IsZero'0.C_IsZero ([%#sopen_inv0] (0 : int32)) ] s1
      | s1 = IsZero'0.t_iszero {a}
          (fun (r0'0:int32) ->
            Int32.sub {r0'0} {[%#sopen_inv1] (1 : int32)}
              (fun (_ret':int32) -> IsZero'0.t_iszero {a} (fun (l_0'0:int32) ->  [ &a <- IsZero'0.C_IsZero _ret' ] s2)))
      | s2 =  [ &_0 <- a ] s3
      | s3 = return' {_0} ]
       ]
    ) [ & _0 : IsZero'0.t_iszero = any_l () | & a : IsZero'0.t_iszero = any_l () ] 
    [ return' (result:IsZero'0.t_iszero)-> (! return' {result}) ]
    
end
module OpenInv_Impl0
  
end
