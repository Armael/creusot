
module C594_TestLogic_Stub
  use mach.int.Int
  use mach.int.UInt32
  function test_logic (_1' : (uint32, uint32)) : uint32
end
module C594_TestLogic_Interface
  use mach.int.Int
  use mach.int.UInt32
  function test_logic (_1' : (uint32, uint32)) : uint32
end
module C594_TestLogic
  use mach.int.Int
  use mach.int.UInt32
  function test_logic [#"../594.rs" 5 0 5 44] (_1' : (uint32, uint32)) : uint32 =
    [#"../594.rs" 6 4 6 5] let (x, _) = _1' in x
  val test_logic (_1' : (uint32, uint32)) : uint32
    ensures { result = test_logic _1' }
    
end
module CreusotContracts_Logic_Resolve_Resolve_Resolve_Stub
  type self
  predicate resolve (self : self)
end
module CreusotContracts_Logic_Resolve_Resolve_Resolve_Interface
  type self
  predicate resolve (self : self)
end
module CreusotContracts_Logic_Resolve_Resolve_Resolve
  type self
  predicate resolve (self : self)
  val resolve (self : self) : bool
    ensures { result = resolve self }
    
end
module CreusotContracts_Logic_Resolve_Impl0_Resolve_Stub
  type t1
  type t2
  predicate resolve (self : (t1, t2))
end
module CreusotContracts_Logic_Resolve_Impl0_Resolve_Interface
  type t1
  type t2
  predicate resolve (self : (t1, t2))
end
module CreusotContracts_Logic_Resolve_Impl0_Resolve
  type t1
  type t2
  clone CreusotContracts_Logic_Resolve_Resolve_Resolve_Stub as Resolve1 with type self = t2
  clone CreusotContracts_Logic_Resolve_Resolve_Resolve_Stub as Resolve0 with type self = t1
  predicate resolve (self : (t1, t2)) =
    Resolve0.resolve (let (a, _) = self in a) /\ Resolve1.resolve (let (_, a) = self in a)
  val resolve (self : (t1, t2)) : bool
    ensures { result = resolve self }
    
end
module CreusotContracts_Logic_Resolve_Impl2_Resolve_Stub
  type t
  predicate resolve (self : t)
end
module CreusotContracts_Logic_Resolve_Impl2_Resolve_Interface
  type t
  predicate resolve (self : t)
end
module CreusotContracts_Logic_Resolve_Impl2_Resolve
  type t
  predicate resolve (self : t) =
    true
  val resolve (self : t) : bool
    ensures { result = resolve self }
    
end
module C594_TestProgram_Interface
  use mach.int.Int
  use mach.int.UInt32
  val test_program [@cfg:stackify] (_1' : (uint32, uint32)) : uint32
    ensures { [#"../594.rs" 9 10 9 21] let (x, _) = _1' in result = x }
    
end
module C594_TestProgram
  use mach.int.Int
  use mach.int.UInt32
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve1 with type t = uint32
  clone CreusotContracts_Logic_Resolve_Impl0_Resolve as Resolve0 with type t1 = uint32, type t2 = uint32,
    predicate Resolve0.resolve = Resolve1.resolve, predicate Resolve1.resolve = Resolve1.resolve
  let rec cfg test_program [@cfg:stackify] [#"../594.rs" 10 0 10 46] (_1' : (uint32, uint32)) : uint32
    ensures { [#"../594.rs" 9 10 9 21] let (x, _) = _1' in result = x }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : uint32;
  var _1 : (uint32, uint32);
  var x_2 : uint32;
  {
    _1 <- _1';
    goto BB0
  }
  BB0 {
    x_2 <- (let (a, _) = _1 in a);
    assume { Resolve0.resolve _1 };
    _0 <- x_2;
    return _0
  }
  
end
module C594_T_Type
  use mach.int.Int
  use mach.int.UInt32
  type t_t  =
    | C_T uint32
    
end
module C594_Impl0_TestMethod_Interface
  use mach.int.Int
  use mach.int.UInt32
  use C594_T_Type as C594_T_Type
  val test_method [@cfg:stackify] (self : C594_T_Type.t_t) (_2' : (uint32, uint32)) : uint32
    ensures { [#"../594.rs" 22 14 22 25] let (x, _) = _2' in result = x }
    
end
module C594_Impl0_TestMethod
  use mach.int.Int
  use mach.int.UInt32
  use C594_T_Type as C594_T_Type
  clone CreusotContracts_Logic_Resolve_Impl2_Resolve as Resolve1 with type t = uint32
  clone CreusotContracts_Logic_Resolve_Impl0_Resolve as Resolve0 with type t1 = uint32, type t2 = uint32,
    predicate Resolve0.resolve = Resolve1.resolve, predicate Resolve1.resolve = Resolve1.resolve
  let rec cfg test_method [@cfg:stackify] [#"../594.rs" 23 4 23 55] (self : C594_T_Type.t_t) (_2' : (uint32, uint32)) : uint32
    ensures { [#"../594.rs" 22 14 22 25] let (x, _) = _2' in result = x }
    
   = [@vc:do_not_keep_trace] [@vc:sp]
  var _0 : uint32;
  var self_1 : C594_T_Type.t_t;
  var _2 : (uint32, uint32);
  var x_3 : uint32;
  {
    self_1 <- self;
    _2 <- _2';
    goto BB0
  }
  BB0 {
    x_3 <- (let (a, _) = _2 in a);
    assume { Resolve0.resolve _2 };
    _0 <- x_3;
    return _0
  }
  
end
