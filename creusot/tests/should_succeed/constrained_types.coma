
module T_core__cmp__Ordering
  type t_Ordering  =
    | C_Less
    | C_Equal
    | C_Greater
  
  let rec v_Less (input:t_Ordering) (ret  )= any
    [ good -> {C_Less  = input} (! ret) | bad -> {C_Less  <> input} (! {false} any) ]
    
  
  let rec v_Equal (input:t_Ordering) (ret  )= any
    [ good -> {C_Equal  = input} (! ret) | bad -> {C_Equal  <> input} (! {false} any) ]
    
  
  let rec v_Greater (input:t_Ordering) (ret  )= any
    [ good -> {C_Greater  = input} (! ret) | bad -> {C_Greater  <> input} (! {false} any) ]
    
end
module M_constrained_types__uses_concrete_instance [#"constrained_types.rs" 14 0 14 67]
  let%span span0 = "../../../creusot-contracts/src/logic/ord.rs" 135 16 141 17
  let%span span1 = "../../../creusot-contracts/src/logic/ord.rs" 122 39 122 84
  let%span span2 = "../../../creusot-contracts/src/logic/ord.rs" 116 40 116 73
  let%span span3 = "../../../creusot-contracts/src/logic/ord.rs" 117 39 117 69
  let%span span4 = "../../../creusot-contracts/src/logic/ord.rs" 110 40 110 70
  let%span span5 = "../../../creusot-contracts/src/logic/ord.rs" 111 39 111 72
  let%span span6 = "../../../creusot-contracts/src/logic/ord.rs" 103 40 103 57
  let%span span7 = "../../../creusot-contracts/src/logic/ord.rs" 104 40 104 57
  let%span span8 = "../../../creusot-contracts/src/logic/ord.rs" 105 39 105 56
  let%span span9 = "../../../creusot-contracts/src/logic/ord.rs" 98 39 98 70
  let%span span10 = "../../../creusot-contracts/src/logic/ord.rs" 93 39 93 89
  let%span span11 = "../../../creusot-contracts/src/logic/ord.rs" 88 39 88 86
  let%span span12 = "../../../creusot-contracts/src/logic/ord.rs" 83 39 83 86
  let%span span13 = "../../../creusot-contracts/src/logic/ord.rs" 78 39 78 89
  let%span span14 = "../../../creusot-contracts/src/logic/ord.rs" 216 8 223 11
  let%span span15 = "../../../creusot-contracts/src/logic/ord.rs" 122 39 122 84
  let%span span16 = "../../../creusot-contracts/src/logic/ord.rs" 116 40 116 73
  let%span span17 = "../../../creusot-contracts/src/logic/ord.rs" 117 39 117 69
  let%span span18 = "../../../creusot-contracts/src/logic/ord.rs" 110 40 110 70
  let%span span19 = "../../../creusot-contracts/src/logic/ord.rs" 111 39 111 72
  let%span span20 = "../../../creusot-contracts/src/logic/ord.rs" 103 40 103 57
  let%span span21 = "../../../creusot-contracts/src/logic/ord.rs" 104 40 104 57
  let%span span22 = "../../../creusot-contracts/src/logic/ord.rs" 105 39 105 56
  let%span span23 = "../../../creusot-contracts/src/logic/ord.rs" 98 39 98 70
  let%span span24 = "../../../creusot-contracts/src/logic/ord.rs" 247 20 247 67
  let%span span25 = "../../../creusot-contracts/src/logic/ord.rs" 93 39 93 89
  let%span span26 = "../../../creusot-contracts/src/logic/ord.rs" 241 20 241 68
  let%span span27 = "../../../creusot-contracts/src/logic/ord.rs" 88 39 88 86
  let%span span28 = "../../../creusot-contracts/src/logic/ord.rs" 235 20 235 67
  let%span span29 = "../../../creusot-contracts/src/logic/ord.rs" 83 39 83 86
  let%span span30 = "../../../creusot-contracts/src/logic/ord.rs" 229 20 229 68
  let%span span31 = "../../../creusot-contracts/src/logic/ord.rs" 78 39 78 89
  let%span span32 = "../../../creusot-contracts/src/invariant.rs" 24 8 24 18
  let%span span33 = "../../../creusot-contracts/src/std/num.rs" 22 16 22 35
  let%span span34 = "../../../creusot-contracts/src/std/tuples.rs" 29 28 29 57
  let%span span35 = "../../../creusot-contracts/src/model.rs" 81 8 81 28
  let%span span36 = "constrained_types.rs" 9 18 9 68
  
  use prelude.prelude.Int
  
  use T_core__cmp__Ordering as Ordering'0
  
  function cmp_log'1 (self : int) (o : int) : Ordering'0.t_Ordering =
    [%#span0] if self < o then Ordering'0.C_Less else if self = o then Ordering'0.C_Equal else Ordering'0.C_Greater
  
  function eq_cmp'1 (x : int) (y : int) : ()
  
  axiom eq_cmp'1_spec : forall x : int, y : int . [%#span1] (x = y) = (cmp_log'1 x y = Ordering'0.C_Equal)
  
  function antisym2'1 (x : int) (y : int) : ()
  
  axiom antisym2'1_spec : forall x : int, y : int . ([%#span2] cmp_log'1 x y = Ordering'0.C_Greater)
   -> ([%#span3] cmp_log'1 y x = Ordering'0.C_Less)
  
  function antisym1'1 (x : int) (y : int) : ()
  
  axiom antisym1'1_spec : forall x : int, y : int . ([%#span4] cmp_log'1 x y = Ordering'0.C_Less)
   -> ([%#span5] cmp_log'1 y x = Ordering'0.C_Greater)
  
  function trans'1 (x : int) (y : int) (z : int) (o : Ordering'0.t_Ordering) : ()
  
  axiom trans'1_spec : forall x : int, y : int, z : int, o : Ordering'0.t_Ordering . ([%#span6] cmp_log'1 x y = o)
   -> ([%#span7] cmp_log'1 y z = o)  -> ([%#span8] cmp_log'1 x z = o)
  
  function refl'1 (x : int) : ()
  
  axiom refl'1_spec : forall x : int . [%#span9] cmp_log'1 x x = Ordering'0.C_Equal
  
  function cmp_gt_log'1 (x : int) (y : int) : ()
  
  axiom cmp_gt_log'1_spec : forall x : int, y : int . [%#span10] (x > y) = (cmp_log'1 x y = Ordering'0.C_Greater)
  
  function cmp_ge_log'1 (x : int) (y : int) : ()
  
  axiom cmp_ge_log'1_spec : forall x : int, y : int . [%#span11] (x >= y) = (cmp_log'1 x y <> Ordering'0.C_Less)
  
  function cmp_lt_log'1 (x : int) (y : int) : ()
  
  axiom cmp_lt_log'1_spec : forall x : int, y : int . [%#span12] (x < y) = (cmp_log'1 x y = Ordering'0.C_Less)
  
  function cmp_le_log'1 (x : int) (y : int) : ()
  
  axiom cmp_le_log'1_spec : forall x : int, y : int . [%#span13] (x <= y) = (cmp_log'1 x y <> Ordering'0.C_Greater)
  
  use prelude.prelude.UInt32
  
  predicate inv'1 (_1 : (uint32, uint32))
  
  axiom inv_axiom'1 [@rewrite] : forall x : (uint32, uint32) [inv'1 x] . inv'1 x = true
  
  use prelude.prelude.Int
  
  function cmp_log'0 (self : (int, int)) (o : (int, int)) : Ordering'0.t_Ordering =
    [%#span14] let r = cmp_log'1 (let (a, _) = self in a) (let (a, _) = o in a) in if r = Ordering'0.C_Equal then
      cmp_log'1 (let (_, a) = self in a) (let (_, a) = o in a)
    else
      r
    
  
  function eq_cmp'0 (x : (int, int)) (y : (int, int)) : ()
  
  axiom eq_cmp'0_spec : forall x : (int, int), y : (int, int) . [%#span15] (x = y)
  = (cmp_log'0 x y = Ordering'0.C_Equal)
  
  function antisym2'0 (x : (int, int)) (y : (int, int)) : ()
  
  axiom antisym2'0_spec : forall x : (int, int), y : (int, int) . ([%#span16] cmp_log'0 x y = Ordering'0.C_Greater)
   -> ([%#span17] cmp_log'0 y x = Ordering'0.C_Less)
  
  function antisym1'0 (x : (int, int)) (y : (int, int)) : ()
  
  axiom antisym1'0_spec : forall x : (int, int), y : (int, int) . ([%#span18] cmp_log'0 x y = Ordering'0.C_Less)
   -> ([%#span19] cmp_log'0 y x = Ordering'0.C_Greater)
  
  function trans'0 (x : (int, int)) (y : (int, int)) (z : (int, int)) (o : Ordering'0.t_Ordering) : ()
  
  axiom trans'0_spec : forall x : (int, int), y : (int, int), z : (int, int), o : Ordering'0.t_Ordering . ([%#span20] cmp_log'0 x y
  = o)  -> ([%#span21] cmp_log'0 y z = o)  -> ([%#span22] cmp_log'0 x z = o)
  
  function refl'0 (x : (int, int)) : ()
  
  axiom refl'0_spec : forall x : (int, int) . [%#span23] cmp_log'0 x x = Ordering'0.C_Equal
  
  use int.Int
  
  function gt_log'0 (self : (int, int)) (o : (int, int)) : bool =
    [%#span24] (let (a, _) = self in a) = (let (a, _) = o in a) /\ (let (_, a) = self in a) > (let (_, a) = o in a)
    \/ (let (a, _) = self in a) > (let (a, _) = o in a)
  
  function cmp_gt_log'0 (x : (int, int)) (y : (int, int)) : ()
  
  axiom cmp_gt_log'0_spec : forall x : (int, int), y : (int, int) . [%#span25] gt_log'0 x y
  = (cmp_log'0 x y = Ordering'0.C_Greater)
  
  use int.Int
  
  function ge_log'0 (self : (int, int)) (o : (int, int)) : bool =
    [%#span26] (let (a, _) = self in a) = (let (a, _) = o in a) /\ (let (_, a) = self in a) >= (let (_, a) = o in a)
    \/ (let (a, _) = self in a) > (let (a, _) = o in a)
  
  function cmp_ge_log'0 (x : (int, int)) (y : (int, int)) : ()
  
  axiom cmp_ge_log'0_spec : forall x : (int, int), y : (int, int) . [%#span27] ge_log'0 x y
  = (cmp_log'0 x y <> Ordering'0.C_Less)
  
  use int.Int
  
  function lt_log'0 (self : (int, int)) (o : (int, int)) : bool =
    [%#span28] (let (a, _) = self in a) = (let (a, _) = o in a) /\ (let (_, a) = self in a) < (let (_, a) = o in a)
    \/ (let (a, _) = self in a) < (let (a, _) = o in a)
  
  function cmp_lt_log'0 (x : (int, int)) (y : (int, int)) : ()
  
  axiom cmp_lt_log'0_spec : forall x : (int, int), y : (int, int) . [%#span29] lt_log'0 x y
  = (cmp_log'0 x y = Ordering'0.C_Less)
  
  use int.Int
  
  function le_log'0 (self : (int, int)) (o : (int, int)) : bool =
    [%#span30] (let (a, _) = self in a) = (let (a, _) = o in a) /\ (let (_, a) = self in a) <= (let (_, a) = o in a)
    \/ (let (a, _) = self in a) < (let (a, _) = o in a)
  
  function cmp_le_log'0 (x : (int, int)) (y : (int, int)) : ()
  
  axiom cmp_le_log'0_spec : forall x : (int, int), y : (int, int) . [%#span31] le_log'0 x y
  = (cmp_log'0 x y <> Ordering'0.C_Greater)
  
  use prelude.prelude.Borrow
  
  predicate invariant'0 (self : (uint32, uint32)) =
    [%#span32] inv'1 self
  
  predicate inv'0 (_1 : (uint32, uint32))
  
  axiom inv_axiom'0 [@rewrite] : forall x : (uint32, uint32) [inv'0 x] . inv'0 x = true
  
  use prelude.prelude.Intrinsic
  
  use prelude.prelude.UInt32
  
  function deep_model'2 (self : uint32) : int =
    [%#span33] UInt32.to_int self
  
  function deep_model'1 (self : (uint32, uint32)) : (int, int) =
    [%#span34] (deep_model'2 (let (a, _) = self in a), deep_model'2 (let (_, a) = self in a))
  
  function deep_model'0 (self : (uint32, uint32)) : (int, int) =
    [%#span35] deep_model'1 self
  
  let rec lt'0 (self:(uint32, uint32)) (other:(uint32, uint32)) (return'  (ret:bool))= {[@expl:precondition] inv'0 other}
    {[@expl:precondition] inv'0 self}
    any
    [ return' (result:bool)-> {[%#span36] result = lt_log'0 (deep_model'0 self) (deep_model'0 other)}
      (! return' {result}) ]
    
  
  meta "compute_max_steps" 1000000
  
  let rec uses_concrete_instance (x:(uint32, uint32)) (y:(uint32, uint32)) (return'  (ret:bool))= (! bb0
    [ bb0 = s0 [ s0 = lt'0 {x} {y} (fun (_ret':bool) ->  [ &_0 <- _ret' ] s1) | s1 = bb1 ]  | bb1 = return' {_0} ]
    ) [ & _0 : bool = any_l () | & x : (uint32, uint32) = x | & y : (uint32, uint32) = y ] 
    [ return' (result:bool)-> (! return' {result}) ]
    
end
