module Type
  use Ref
  use mach.int.Int
  use prelude.Int8
  use prelude.Int16
  use mach.int.Int32
  use mach.int.Int64
  use prelude.UInt8
  use prelude.UInt16
  use mach.int.UInt32
  use mach.int.UInt64
  use string.Char
  use floating_point.Single
  use floating_point.Double
  use seq.Seq
  use prelude.Prelude
end
module Core_Tuple_Impl7_Lt_Interface
  type k
  type l
  use prelude.Prelude
  val lt [@cfg:stackify] (self : (k, l)) (other : (k, l)) : bool
    requires {false}
    
end
module Core_Tuple_Impl7_Lt
  type k
  type l
  use prelude.Prelude
  val lt [@cfg:stackify] (self : (k, l)) (other : (k, l)) : bool
    requires {false}
    
end
module Core_Tuple_Impl7
  type k
  type l
end
module ConstrainedTypes_UsesConcreteInstance_Interface
  use mach.int.Int
  use mach.int.UInt32
  val uses_concrete_instance [@cfg:stackify] (x : (uint32, uint32)) (y : (uint32, uint32)) : bool
end
module ConstrainedTypes_UsesConcreteInstance
  use mach.int.Int
  use mach.int.UInt32
  use prelude.Prelude
  clone Core_Tuple_Impl7_Lt_Interface as Lt0 with type k = uint32, type l = uint32
  let rec cfg uses_concrete_instance [@cfg:stackify] [#"../constrained_types.rs" 1 0 63] (x : (uint32, uint32)) (y : (uint32, uint32)) : bool
    
   =
  var _0 : bool;
  var x_1 : (uint32, uint32);
  var y_2 : (uint32, uint32);
  var _3 : (uint32, uint32);
  var _4 : (uint32, uint32);
  {
    x_1 <- x;
    y_2 <- y;
    goto BB0
  }
  BB0 {
    _3 <- x_1;
    _4 <- y_2;
    _0 <- ([#"../constrained_types.rs" 2 4 9] Lt0.lt _3 _4);
    goto BB1
  }
  BB1 {
    return _0
  }
  
end
module ConstrainedTypes_Main_Interface
  val main [@cfg:stackify] (_ : ()) : ()
end
module ConstrainedTypes_Main
  let rec cfg main [@cfg:stackify] [#"../constrained_types.rs" 5 0 9] (_ : ()) : () =
  var _0 : ();
  {
    goto BB0
  }
  BB0 {
    _0 <- ();
    return _0
  }
  
end
