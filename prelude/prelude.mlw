module Opaque
  type opaque_ptr
end
module Bool
  let eqb (a : bool) (b : bool) : bool =
    ensures { result <-> a = b  }
    match a, b with
    | True, True -> True
    | False, False -> True
    | _ -> False
    end

  let neqb (a : bool) (b : bool) : bool =
    ensures { result <-> a <> b  }
    not (eqb a b)
end
module Borrow
  type borrowed 'a = { current : 'a ; final : 'a; }
  let function ( *_ ) x = x.current
  let function ( ^_ ) x = x.final
  val borrow_mut (a : 'a) : borrowed 'a
  ensures { *result = a }
end
module Slice
  use seq.Seq
  type rust_array 'a = seq 'a
  function id (s : seq 'a) : seq 'a = s
end
module IntSize
  use export mach.int.Int64
  type isize = int64
end
module UIntSize
  use export mach.int.UInt64
  type usize = uint64
end
module Int8
  use int.Int

  type int8 = < range -0x80 0x7f >

  let constant min_int8 : int = - 0x80
  let constant max_int8 : int =   0x7f
  function to_int (x : int8) : int = int8'int x

  clone export mach.int.Bounded_int with
    type t = int8,
    constant min = int8'minInt,
    constant max = int8'maxInt,
    function to_int = int8'int,
    lemma to_int_in_bounds,
    lemma extensionality
end
module Int16
  use int.Int

  type int16 = < range -0x8000 0x7fff >

  let constant min_int16 : int = - 0x8000
  let constant max_int16 : int =   0x7fff
  function to_int (x : int16) : int = int16'int x

  clone export mach.int.Bounded_int with
    type t = int16,
    constant min = int16'minInt,
    constant max = int16'maxInt,
    function to_int = int16'int,
    lemma to_int_in_bounds,
    lemma extensionality
end
module Int128
  use int.Int

  type int128 = < range -0x80000000000000000000000000000000 0x7fffffffffffffffffffffffffffffff >

  let constant min_int128 : int = - 0x80000000000000000000000000000000
  let constant max_int128 : int =   0x7fffffffffffffffffffffffffffffff
  function to_int (x : int128) : int = int128'int x

  clone export mach.int.Bounded_int with
    type t = int128,
    constant min = int128'minInt,
    constant max = int128'maxInt,
    function to_int = int128'int,
    lemma to_int_in_bounds,
    lemma extensionality
end
module UInt8
  use int.Int

  type uint8 = < range 0x0 0xff >

  let constant min_uint8 : int =  0x00
  let constant max_uint8 : int =  0xff
  function to_int (x : uint8) : int = uint8'int x

  clone export mach.int.Bounded_int with
    type t = uint8,
    constant min = uint8'minInt,
    constant max = uint8'maxInt,
    function to_int = uint8'int,
    lemma to_int_in_bounds,
    lemma extensionality
end
module UInt16
  use int.Int

  type uint16 = < range 0x0 0xffff >

  let constant min_uint16 : int =  0x00
  let constant max_uint16 : int =  0xffff
  function to_int (x : uint16) : int = uint16'int x

  clone export mach.int.Bounded_int with
    type t = uint16,
    constant min = uint16'minInt,
    constant max = uint16'maxInt,
    function to_int = uint16'int,
    lemma to_int_in_bounds,
    lemma extensionality
end
module UInt128
  use int.Int

  type uint128 = < range 0x0 0xffffffffffffffffffffffffffffffff >

  let constant min_uint128 : int =  0x00000000000000000000000000000000
  let constant max_uint128 : int =  0xffffffffffffffffffffffffffffffff
  function to_int (x : uint128) : int = uint128'int x

  clone export mach.int.Bounded_int with
    type t = uint128,
    constant min = uint128'minInt,
    constant max = uint128'maxInt,
    function to_int = uint128'int,
    lemma to_int_in_bounds,
    lemma extensionality
end
module Char
  (* utf8 characters (not glyphs) *)
  use string.String
  use int.Int

  type char = abstract {
    contents: string;
  } invariant {
    length contents = 1
  }

  (* is this necessary?? *)
  axiom char_eq: forall c1 c2.
    c1.contents = c2.contents -> c1 = c2

  function code char : int

  axiom code: forall c. 0 <= code c < 0x10FFFF

  function chr (n: int) : char

  axiom code_chr: forall n. 0 <= n < 0x10FFFF -> code (chr n) = n

  axiom chr_code: forall c. chr (code c) = c

  function get (s: string) (i: int) : char

  axiom get: forall s i.
    0 <= i < length s -> (get s i).contents = s_at s i

  axiom substring_get:
    forall s ofs len i.
    0 <= ofs <= length s -> 0 <= len -> ofs + len <= length s -> 0 <= i < len ->
    get (substring s ofs len) i = get s (ofs + i)

  lemma concat_first: forall s1 s2.
    let s3 = concat s1 s2 in
    forall i. 0 <= i < length s1 ->
      get s3 i = get s1 i

  lemma concat_second: forall s1 s2.
    let s3 = concat s1 s2 in
    forall i. length s1 <= i < length s1 + length s2 ->
      get s3 i = get s2 (i - length s1)

  function ([]) (s: string) (i: int) : char = get s i

  predicate eq_string (s1 s2: string) = length s1 = length s2 &&
    (forall i. 0 <= i < length s1 -> get s1 i = get s2 i)

  axiom extensionality [@W:non_conservative_extension:N]:
    forall s1 s2. eq_string s1 s2 -> s1 = s2

  function make (size: int) (v: char) : string

  axiom make_length: forall size v. size >= 0 ->
    length (make size v) = size

  axiom make_contents: forall size v. size >= 0 ->
    (forall i. 0 <= i < size -> get (make size v) i = v)

end

